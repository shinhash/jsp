servlet ==> spring controller 
ms-sql servet ==> oracle
like 마이그레이션

주의점
컨트롤러 메서드 인자 설정시 발생할 수 있는 문제점
1. primitive type (int, double)
	메서드(int page)
		==> page 파라미터가 반드시 존재해야한다.(없으면 error!!!)



개발시 고려 사항 : 해당 파라미터가 반드시 전송이 되는가!!
	전송 될 경우 : 별다른 조치 없이 사용
	전송 안될 경우 : @RequestParam(name="파라미터명", required=false, defaultValue="")
					또는 Command 객체 사용
					** primitive type의 필드는 객체 생성시 자동으로 초기 값으로 할당이 된다.


개발자 도구에서 initData()함수를 호출하여 간편하게 테스트를 수행한다.
function initData(){
		$("#userid").val("shs");
		$("#usernm").val("신하승");
		$("#alias").val("java");
		$("#pass").val("pass1234");
		$("#addr1").val("대전 중구 중앙로 76");
		$("#addr2").val("영민빌딩 4충 404호");
		$("#zipcode").val("34904");
	}




스프링 객체 검증
1. Spring Validator
	1. 스프링 프레임워크에서 제공하는 Validator interface를 구현
		. supports : 검증하려고 하는 객체가 해당 validator에서 검증할 수 있는지 여부를 반환
		. validate : 검증 로직을 작성-개발자가 로직을 직접 구현
		
	2. Controller 메서드에 검증하려고 하는 커맨드 객체 바로 뒤에 BindingResult객체를 인자로 선언
		스프링 프레임워크에서 메서드 인자 구성이 비교적 자유롭지만
		BindingResult 객체는 검증을 하려고 하는 커맨드 객체뒤에 반드시 선언이 되어있어야한다.


			Spring Validator 사용방법
			
			1. root-context.xml 에 등록(service, dao 에서도 사용가능성이 존재하기 때문에 부모쪽에 선언을 해준다.)
			
				<!-- messageSource 등록 : bean id는 messageSource로 정해져 있다. 
					 번들메시지_언어코드_국가코드.properties ==> 번들메세지(kr/or/ddit/message/msg)
					 kr/or/ddit/message/msg_kr.properites
				-->
				<bean id="messageSource" class="org.springframework.context.support.ReloadableResourceBundleMessageSource">
					<property name="basenames">
						<list>
							<value>classpath:kr/or/ddit/message/msg</value>
						</list>
					</property>
				</bean>	
			
			
			2. 검증객체를 생성후 Validator(검증객체)를 implements 한다.
			
				package kr.or.ddit.member.model;
			
				import org.springframework.validation.Errors;
				import org.springframework.validation.Validator;
				
				public class MemberVOValidator implements Validator{
					
					// 검증하려고 하는 객체가 MemberVOValidator에서 검증이 가능한
					// 객체인지 boolean으로 리턴하는 메서드
					// vo객체.class.isAssignableFrom(clazz); ==> 해당 vo클래스와 관련이 있는지에 대한 여부
					@Override
					public boolean supports(Class<?> clazz) {
						return MemberVO.class.isAssignableFrom(clazz);
					}
				
					// 검증 로직을 작성하는 메서드
					// Object target : command 객체
					@Override
					public void validate(Object target, Errors errors) {
						MemberVO memVO = (MemberVO)target;
						
						// usernm 값이 null이거나 empty 문자열이면 안됨
						if(memVO.getUsernm() == null || memVO.getUsernm().equals("")) {
							errors.rejectValue("usernm", "required");
						}
					}
				}
			
			
			
			3. 검증하고자 하는 객체의 바로 뒤에 BindingResult를 선언하고 ==> (MemberVO memVO, BindingResult br)
				new 검증객체().validate(검증하려고하는 객체, 검증객체 변수); 를 작성 (검증 객체를 생성한다.)
			
				@RequestMapping(path="/regist", method = RequestMethod.POST)
				public String memRegistInsert(MemberVO memVO, BindingResult br, @RequestPart("file") MultipartFile file) {
					
					new MemberVOValidator().validate(memVO, br);
					
					if(br.hasErrors()) {
						return "member/memberRegist";
					}
		
			
			4. msg.properties 파일을 생성 후 다음을 작성
				## 에러코드[.객체].필드명=메세지
				required.usernm=사용자 이름이 누락되었습니다.
				
				
				
				
			5. 해당 jsp에서 다음을 작성
				<span style="color:red;"><form:errors path="memberVO.usernm" /></span>




2. JSR303 유효성 검증
	1. Command 객체 인자 앞에 @Valid 어노테이션 적용
	2. Command 객체의 필드에 검증 어노테이션을 적용
	3. Command 객체 뒤에 BindingResult 객체를 인자로 선언
		객체 검증의 결과가 bindingResult 객체에 담긴다.
		==> 개발자가 직접 검증과 관련된 메서드를 호출하지 않는다.
		
		Spring Validator와 비교 ==> 복잡한 검증은 불가능
		@Max, @Min, @Size, @Pattern(정규식) 등 간단한 형태만 가능
		**복잡한 형태 : 네이버에 비밀번호 변경시 기존에 사용하던 비밀번호를 사용하지 못하게끔 설정
		
		
		사용방법
		
		1. pom.xml에 다음을 추가
		
			<!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-validator -->
			<dependency>
			    <groupId>org.hibernate</groupId>
			    <artifactId>hibernate-validator</artifactId>
			    <version>5.1.3.Final</version>
			</dependency>


			
		2. 에러 체크를 하려는 객체VO의 필드위에 @에러코드를 작성한다.
		
			// null이면 안되고, empty체크 
			@NotEmpty
			private String usernm;



		3. 검증하려고 하는 객체의 앞에 @Valid를 작성한다.
			
			public String memRegistInsert(@Valid MemberVO memVO, 
			
		
		
			
		4. msg.properties 파일을 생성 후 다음을 작성
		
			##에러코드[.객체].필드명=메세지
			NotEmpty.usernm=JSR303 사용자 이름이 누락되었습니다.
			
		
			
			
		5. jsp에 다음을 작성한다.
		
			<span style="color:red;"><form:errors path="memberVO.usernm" /></span>






스프링 예외처리
1. Controller 마다 처리
	Controller class에 @ExceptionHandler 어노테이션이 적용된 메서드를 생성
	어노테이션 속성으로 해당 메서드에서 처리할 예외에 대한 선언
	해당 예외가 발생시 @ExceptionHandler 어노테이션이 적용된 메서드가 호출된다.
	
		사용방법
		@RequestMapping("/exception/view")
		public String view() {
			throw new ArithmeticException();
		}
		
		@ExceptionHandler({ArithmeticException.class})
		public String handler() {
			
			// 에러를 처리할 화면으로 이동
			return "exception/arithmetic";
		}
		
		
		
		
	
2. 공통의 예외처리 클래스로 분리
	. 예외처리를 할 클래스를 생성, 클래스에 @ControllerAdvice 어노테이션 적용
	. 해당 클래스의 예외처리 메서드는 @ExceptionHandler 어노테이션을 적용, 처리 가능한 예외타입에 대해 등록
	. @ControllerAdvice 어노테이션이 적용된 클래스를 스캔할 수 있도록
		Component-scan 엘레멘트를 수정
		
		application-context.xml 수정
		
		<context:component-scan base-package="kr.or.ddit" use-default-filters="false">
			<context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
		</context:component-scan>
		
		여기에 
		<context:include-filter type="annotation" expression="org.springframework.web.bind.annotation.ControllerAdvice"/>
		추가
		
		추가 후 @ControllerAdvice 어노테이션 사용가능
		
		
		
		사용방법
		
		@RequestMapping("/exception/respSt")
		public String responseStatus() throws NoFileException {
			try {
				
				// 파일을 찾는 로직이 있다.
				// 찾고자 하는 파일이 없어서 예외발생
				throw new Exception();
			}catch(Exception e) {
				
				// Exception 대신 우리가 만든 NoFileException으로 처리
				// NoFileException은 @ResponseStatus 설정에 의해
				// 404 코드로 사용자에게 응답 처리됨
				
				throw new NoFileException();
			}
		}
		
		
		
		
		
		ExceptionAdvice class
		
		package kr.or.ddit.mvc.exception.web;

		import org.slf4j.Logger;
		import org.slf4j.LoggerFactory;
		import org.springframework.web.bind.annotation.ControllerAdvice;
		import org.springframework.web.bind.annotation.ExceptionHandler;
		
		@ControllerAdvice
		public class ExceptionAdvice {
		
			private static final Logger logger = LoggerFactory.getLogger(ExceptionAdvice.class);
		
			
			@ExceptionHandler({ArithmeticException.class})
			public String handler() {
				logger.debug("ExceptionController.handler()");
				
				// 에러를 처리할 화면으로 이동
				return "exception/arithmetic";
			}
		}
		
		





3. 사용자 정의 예외가 발생시 스프링 프레임워크에게 응답코드를 설정하는 방법







정적자원 매핑 처리
	1. url 단축을 목적
	2. WEB-INF : 외부에서 접근불가능한 공간에 저장된 자원들 접근 매핑
	
	사용이유
	예외처리 페이지로 이동시 해당 jsp or html의 경로가 WEB-INF밑에 있을 경우 해당 경로의 css와 js를 불러오지 못하기 때문이다.
	
	해결방안
	application-context.xml에 다음을 추가
	<mvc:resources mapping="/resources/**" location="/WEB-INF/views/error/"></mvc:resources>

	설명
	mapping ==> 해당 요청 경로
	location ==> 가야하는 경로


